package mine;

public class NoteWrite {
    /*
    <자바 메모리 구조>
    메서드 영역 : - 클래스 정보를 보관함.(붕어빵 틀 보관)
                - 프로그램을 실행하는데 필요한 공통 데이터 관리.
                - 메서드 영역은 프로그램의 모든 영역에서 공유함.
                - 클래스의 실행 코드, 필드, 메서드와 생성자 코드 등 모든 실행코드 존재.
                - static 변수들을 보관.
    스택 영역 : - 실제 프로그램이 실행되는 영역. 메서드를 실행할 때마다 하나씩 쌓임.
               - 메인을 실행하면 메인이 쌓이고 그 안의 메서드를 실행하면 메인 위에
                메서드가 쌓임.
               - 자바를 실행하면 하나의 실행 스택이 생성됨.
               - 쓰레드 수 만큼 스택 영역이 생성됨. 나중에 더 자세히 배움.

               - 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가
                    종료되면 해당 스택 프레임이 제거됨. 나머지 메인 부분 실행.
               - 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함.

    힙 영역 : - new를 통해 생성된 인스턴스들이 보관됨.
             - 붕어빵 틀에서 생성된 붕어빵들이 존재하는 공간.
             - 배열도 힙 영역에 생성됨.

        특정 클래스로 100개의 인스턴스를 생성하면 힙 메모리에 100개의 인스턴스가 생김.
        각각의 인스턴스는 내부에 변수와 메서드를 가지는데 변수 값은 서로 다르기 때문에
        메모리가 할당 되지만 메서드는 같기 때문에 메서드 영역에서 공통으로 관리되고
        실행됨.
        -> 인스턴스의 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러서 실행함.


    <변수와 생명주기>
    지역 변수(매개 변수도 포함) : 지역 변수는 스택 영역에 있는 스택 프레임 안에 보관됨.
        매서드가 종료되면 스택 프레임도 제거 되는데 이때 해당 스택 프레임에 포함된
        지역 변수도 함꼐 제거됨. -> 생존 주기가 짧음.

    인스턴스 변수 : 인스턴스에 있는 멤버 변수를 인스턴스 변수라고 함. 힙 영역을 사용.
        GC가 발생하기 전까지는 생존하기 때문에 지역 변수보다 생존 주기가 긺.

    클래스 변수 : 메서드 영역의 static 영역에 보관되는 변수. 메서드 영역은 프로그램
        전체에서 사용하는 공용 공간임. 클래스 변수는 해당 클래스가 jvm에 로딩 되는 순간
        생성됨. jvm이 종료될 때까지 유지.


    정적 메서드는 static이 붙은 정적 메서드나 정적 변수만 사용할 수 있음.
        -> 정적 메서드는 인스턴스 변수나 인스턴스 메서드를 사용할 수 없음.
        -> 하지만 모든 곳에서 static을 호출할 수 있음.
        -> static 메서드를 구성할 때 인스턴스에 접근 못 한다는 뜻.



    main() 메서드
    main()이 호출하는 메서드는 static이 붙은 메서드임. 그 이유는 main() 메서드가
    static메서드이고 static메서드는 같은 클래스 내의 static메서드만 호출 가능하기 때문.





    <상속과 메모리 구조>        extends01.ex02 참고.
    new ElectricCar()를 호출하면 ElectricCar 뿐만 아니라 상속 관계에 엤는 Car까지
    함께 포함해서 인스턴스를 생성함.
    하나의 참조값(x001) 안에 Car, ElectricCar 두 개의 클래스 정보가 같이 들어있음.
    상속이라는 게 단순히 필드와 메서드만 물려받는 게 아니라 인스턴스를 생성할 때 부모 클래스도
    함께 포함해서 생성하게 됨.
    외부에서 볼 때는 하나의 인스턴스를 생성하는 것 같지만, 내부에서는 부모와 자식이 모두
    생성되고 공간도 구분됨.

    electricCar.charge()(본인이 갖고 있는 메서드)를 호출하면 참조값을 확인해서
    x001.charge()를 호출함. 그런데 상속 관계의 경우 내부에 부모와 자식이 모두 존재함.
    이때에는 호출하는 변수의 타입(클래스)를 기준으로 선택함. electricCar의 변수 타입이
    ElectricCar이므로 인스턴스 내부에서 같은 타입인 ElectricCar를 먼저 확인하여
    charge()를 찾음.

    ElectricCar.move()를 호출하면 먼저 x001 참조값으로 이동함. 내부에 있는 Car()과
    ElectricCar()를 만나면 먼저 호출 변수인 electricCar의 타입인 ElectricCar를 먼저
    확인하고 없으면 그 부모 타입으로 올라가서 Car()에서 move()를 찾음.
    부모에서도 해당 기능을 찾지 못하면 더 상위 부모에서 필요한 기능을 찾음.








    <접근 제어자>
    public : 모든 외부 호출을 허용
    protected : 같은 패키지 안에서의 호출은 허용. 패키지는 달라도 상속 관계의 호출은 허용
    default(package-private) : 같은 패키지 안에서 호출은 허용.
    private : 모든 외부 호출을 막는다.



    private<default<protected<public

















     */
}
